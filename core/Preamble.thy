(*<*)

(* Author: Kyndylan Nienhuis *)

theory Preamble

imports 
  Main
  WordExtra
  "$ISABELLE_HOME/src/HOL/Eisbach/Eisbach"
  "$ISABELLE_HOME/src/HOL/Eisbach/Eisbach_Tools"
begin

(*>*)
section \<open>Preamble\<close>

text \<open>In this theory we define simplification lemmas that can be used to rewrite definitions of
instructions (for example generated by L3 or Sail). Some of those lemmas will always simplify an
expression, in which case we add them to the simp set. Other lemmas will only simplify an expression
if it is in a certain shape, or when combined with other lemmas. We define a separate attribute
\<^emph>\<open>alt_def_simp\<close> for these lemmas, so we can use them to rewrite generated definitions, but they will
not affect other proof methods. Conversely, some simplification lemmas are unhelpful when we rewrite
generated definitions. To collect these lemmas we define the attribute \<^emph>\<open>alt_def_simp_del\<close>.\<close>

named_theorems alt_def_simp
named_theorems alt_def_simp_del

subsection \<open>Orders\<close>

subsubsection \<open>@{term Downclosed}\<close>

definition Downclosed :: "'a::preorder set \<Rightarrow> 'a set" where
  "Downclosed A \<equiv> {x. \<exists>y\<in>A. x \<le> y}"

lemma DownclosedI [elim]:
  assumes "y \<in> A" 
      and "x \<le> y"
  shows "x \<in> Downclosed A"
using assms 
unfolding Downclosed_def 
by auto

lemma DownclosedI2 [elim!]:
  assumes "x \<in> A" 
  shows "x \<in> Downclosed A"
using DownclosedI[OF assms]
by auto

lemma DownclosedE [elim]:
  assumes "x \<in> Downclosed A"
  obtains y where "y \<in> A"  and "x \<le> y"
using assms 
unfolding Downclosed_def 
by auto

definition IsDownclosed :: "'a::preorder set \<Rightarrow> bool" where
  "IsDownclosed A \<equiv> (\<forall>x y. x \<le> y \<and> y \<in> A \<longrightarrow> x \<in> A)"

lemma IsDownclosedI [intro]:
  assumes "\<And>x y. x \<le> y \<Longrightarrow> y \<in> A \<Longrightarrow> x \<in> A" 
  shows "IsDownclosed A"
using assms 
unfolding IsDownclosed_def 
by auto

lemma IsDownclosedE [elim]:
  assumes "IsDownclosed A"
      and "x \<le> y"
      and "y \<in> A"
  shows "x \<in> A"
using assms 
unfolding IsDownclosed_def 
by auto

lemma IsDownclosed_DownclosedIdem:
  shows "(Downclosed A = A) = IsDownclosed A"
proof
  assume "IsDownclosed A"
  show "Downclosed A = A"
    proof (intro equalityI subsetI)
      fix x
      assume "x \<in> Downclosed A"
      then obtain y where "x \<le> y" "y \<in> A" by auto
      thus "x \<in> A" using `IsDownclosed A` by auto
    qed auto
next
  assume "Downclosed A = A"
  show "IsDownclosed A"
    proof
      fix x y
      assume "x \<le> y" "y \<in> A"
      hence "x \<in> Downclosed A" by auto
      thus "x \<in> A" using `Downclosed A = A` by auto
    qed
qed

lemma DownclosedIdemI [intro!]:
  assumes "IsDownclosed A"
  shows "Downclosed A = A"
using assms IsDownclosed_DownclosedIdem
by metis

lemma DownclosedIsDownclosed [simp, intro!]:
  shows "IsDownclosed (Downclosed A)"
proof 
  fix x y
  assume "x \<le> y" "y \<in> Downclosed A"
  then obtain z where "y \<le> z" "z \<in> A"
    by auto
  hence "x \<le> z"
    using `x \<le> y` order_trans by auto
  thus "x \<in> Downclosed A"
    using `z \<in> A` by auto
qed

lemma IdemDownclosed [simp]:
  shows "Downclosed (Downclosed A) = Downclosed A"
by auto

lemma DownclosedSubsetIff [simp]:
  shows "(Downclosed A \<subseteq> Downclosed B) = (A \<subseteq> Downclosed B)"
proof (intro iffI subsetI)
  fix x
  assume "x \<in> Downclosed A" 
  then obtain y where "x \<le> y" "y \<in> A"
    by auto
  assume "A \<subseteq> Downclosed B"
  hence "y \<in> Downclosed B"
    using `y \<in> A` by auto
  note DownclosedI[OF this `x \<le> y`]
  thus "x \<in> Downclosed B"
    by auto
qed auto

lemma DownclosedSubsetE [elim]:
  assumes "A \<subseteq> Downclosed B"
      and "x \<in> Downclosed A"
  shows "x \<in> Downclosed B"
proof -
  have "Downclosed A \<subseteq> Downclosed B"
    using assms(1) by simp
  from subsetD[OF this assms(2)]
  show "x \<in> Downclosed B" .
qed

subsubsection \<open>Unfolding\<close>

thm case_bool_if
declare case_bool_if [alt_def_simp]

thm linorder_class.not_le
declare linorder_class.not_le [alt_def_simp]

thm linorder_class.not_less
declare linorder_class.not_less [alt_def_simp]

subsection \<open>Products\<close>

lemma prod_simps [simp]:
  shows "(case x of (a, b) \<Rightarrow> f a) = f (fst x)"
    and "(case x of (a, b) \<Rightarrow> g b) = g (snd x)"
by (auto split: prod.split)

lemma case_prod_of_case_prod [simp]:
  shows "(case case x of (a, b) \<Rightarrow> (f a b, f' a b) of (c, d) \<Rightarrow> g c d) =
         (case x of (a, b) \<Rightarrow> g (f a b) (f' a b))"
by (auto split: prod.split)

lemma projection_of_if_prod [simp]:
  shows "fst (if b then (x, y) else (x', y')) = (if b then x else x')"
  and   "snd (if b then (x, y) else (x', y')) = (if b then y else y')"
by simp_all

lemma projection_of_case_prod [simp]:
  shows "fst (case x of (a, b) \<Rightarrow> (f a b, f' a b)) = (case x of (a, b) \<Rightarrow> f a b)"
    and "snd (case x of (a, b) \<Rightarrow> (f a b, f' a b)) = (case x of (a, b) \<Rightarrow> f' a b)"
by (auto split: prod.split)

subsection \<open>Cases\<close>

lemma if_left_TrueI [intro!]:
  assumes "\<not> x \<Longrightarrow> Q"
  shows "if x then True else Q"
using assms
by auto

lemma if_right_TrueI [intro!]:
  assumes "x \<Longrightarrow> Q"
  shows "if x then Q else True"
using assms
by auto

lemma option_left_TrueI [intro!]:
  assumes "\<And>y. x = Some y \<Longrightarrow> Q y"
  shows "case x of None \<Rightarrow> True | Some y \<Rightarrow> Q y"
using assms
by (cases x) auto

lemma option_right_TrueI [intro!]:
  assumes "x = None \<Longrightarrow> Q"
  shows "case x of None \<Rightarrow> Q | Some y \<Rightarrow> True"
using assms
by (cases x) auto

lemma list_left_TrueI [intro!]:
  assumes "\<And>h t. x = h # t \<Longrightarrow> Q h t"
  shows "case x of [] \<Rightarrow> True | h # t \<Rightarrow> Q h t"
using assms
by (cases x) auto

lemma list_right_TrueI [intro!]:
  assumes "x = [] \<Longrightarrow> Q"
  shows "case x of [] \<Rightarrow> Q | h # t \<Rightarrow> True"
using assms
by (cases x) auto

lemmas ifD [dest] = 
  if_splits(1)[where P="\<lambda>x. x", THEN iffD1]

lemmas optionD [dest] = 
  option.splits(1)[where P="\<lambda>x. x", THEN iffD1]

lemmas listD [dest] = 
  list.splits(1)[where P="\<lambda>x. x", THEN iffD1]

lemmas prodD [dest] = 
  prod.splits(1)[where P="\<lambda>x. x", THEN iffD1]

subsection \<open>Natural numbers and integers\<close>

lemma less_diff_iff':
  fixes a b c d :: nat
  assumes "a \<le> c" 
  shows "(c - a < c - b) = (b < a)"
using assms
by auto

subsection \<open>Words\<close>

declare ucast_shiftr [alt_def_simp]
declare ucast_shiftl [alt_def_simp]
declare ucast_not [alt_def_simp]
declare ucast_or [alt_def_simp]    
declare ucast_and [alt_def_simp]
declare ucast_xor [alt_def_simp]
declare ucast_plus_down [alt_def_simp]
declare ucast_minus_down [alt_def_simp]

lemma scast_alt_def_sym [alt_def_simp]:
  fixes x :: "'a::len word"
  assumes "LENGTH('c) = LENGTH('a) + LENGTH('b)"
      and "m = LENGTH('a) - 1"
  shows "(word_cat (if x !! m then max_word else 0::'b::len word) x) = 
         (scast x::'c::len word)"
using assms
by (simp add: scast_alt_def)

(* If child theories also import \<^emph>\<open>Words\<close> then it is undefined whether @{const bin_to_bl_def} will
be in the simp set or not (see the Isabelle Tutorial 3.1.2). We therefore need to delete is again
from any such child theory. *)

thm bin_to_bl_def
declare bin_to_bl_def [simp del]

lemma if_1_word_0th [simp]:
  shows "(if b then (1 :: 1 word) else 0) !! 0 = b"
by simp

lemma scast_scast_shiftl_unat [alt_def_simp]:
  fixes x :: "'a::len word"
    and y :: "'b::len word"
  assumes "LENGTH('a) + 2 ^ LENGTH('b) - 1 \<le> LENGTH('c)"
  shows "scast ((scast x::'c::len word) << (unat y)) = scast x << (unat y)"
proof -
  have "unat y \<le> 2 ^ LENGTH('b) - 1"
    using unat_lt2p[where x=y]
    by arith
  from add_left_mono[where c="LENGTH('a)", OF this]
  have "LENGTH('a) + unat y \<le> LENGTH('c)"
    using assms
    by auto
  from scast_scast_shiftl[OF this]
  show ?thesis .
qed

paragraph \<open>Folding\<close>

lemmas sym_ucast_def [alt_def_simp] = 
  ucast_def[THEN sym]

lemmas sym_uint_nat [alt_def_simp] = 
  uint_nat[THEN sym]

lemmas sym_unat_def [alt_def_simp] = 
  unat_def[THEN sym]

paragraph \<open>Word case split\<close>

text \<open>The definitions of some instructions contain a conditional branch that can never be taken
(since @{typ "2 word"} can only be 0, 1, 2 or 3) and that branch is @{term undefined}. This makes
the proofs more difficult, so we simplify those expressions.\<close>

lemma twoWord_if [alt_def_simp]:
  fixes t :: "2 word"
  shows "(if t = 0 then m0 
          else if t = 1 then m1 
          else if t = 2 then m2 
          else if t = 3 then m3 
          else m4) = 
         (if t = 0 then m0 
          else if t = 1 then m1 
          else if t = 2 then m2 
          else m3)"
proof -
  obtain n where t: "t = of_nat n" and "n < 4"
    by (cases t) auto
  hence "n = 0 \<or> n = 1 \<or> n = 2 \<or> n = 3"
    by auto
  thus ?thesis 
    using t by auto
qed

lemma threeWord_if [alt_def_simp]:
  fixes t :: "3 word"
  shows "(if t = 0 then m0 
          else if t = 1 then m1 
          else if t = 2 then m2 
          else if t = 3 then m3 
          else if t = 4 then m4 
          else if t = 5 then m5 
          else if t = 6 then m6 
          else if t = 7 then m7 
          else m8) = 
         (if t = 0 then m0 
          else if t = 1 then m1 
          else if t = 2 then m2 
          else if t = 3 then m3 
          else if t = 4 then m4 
          else if t = 5 then m5 
          else if t = 6 then m6 
          else m7)"
proof -
  obtain n where t: "t = of_nat n" and "n < 8"
    by (cases t) auto
  hence "n = 0 \<or> n = 1 \<or> n = 2 \<or> n = 3 \<or> n = 4 \<or> n = 5 \<or> n = 6 \<or> n = 7"
    by auto
  thus ?thesis 
    using t by auto
qed

lemma word_twoWord_if [alt_def_simp]:
  fixes t :: "1 word"
    and s :: "2 word"
  shows "(if t = 0 \<and> s = 0 then m0
          else if t = 0 \<and> s = 1 then m1
          else if t = 0 \<and> s = 2 then m2
          else if t = 0 \<and> s = 3 then m3
          else if t = 1 \<and> s = 0 then m4
          else if t = 1 \<and> s = 1 then m5
          else if t = 1 \<and> s = 2 then m6
          else if t = 1 \<and> s = 3 then m7
          else m8) = 
         (if t = 0 \<and> s = 0 then m0
          else if t = 0 \<and> s = 1 then m1
          else if t = 0 \<and> s = 2 then m2
          else if t = 0 \<and> s = 3 then m3
          else if t = 1 \<and> s = 0 then m4
          else if t = 1 \<and> s = 1 then m5
          else if t = 1 \<and> s = 2 then m6
          else m7)"
proof -
  obtain n where t: "t = of_nat n" and "n < 2"
    by (cases t) auto
  hence n: "n = 0 \<or> n = 1"
    by auto
  hence t2: "t = 0 \<or> t = 1"
    using t by auto
  obtain m where s: "s = of_nat m" and "m < 4"
    by (cases s) auto
  hence m: "m = 0 \<or> m = 1 \<or> m = 2 \<or> m = 3"
    by auto
  hence s2: "s = 0 \<or> s = 1 \<or> s = 2 \<or> s = 3"
    using s by auto
  thus ?thesis 
    using t2 s2 by auto
qed

(*<*)
end
(*>*)